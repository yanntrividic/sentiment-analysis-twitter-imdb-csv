<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.model.data_extraction.network_utils API documentation</title>
<meta name="description" content="Created on Apr 15, 2021 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.model.data_extraction.network_utils</code></h1>
</header>
<section id="section-intro">
<p>Created on Apr 15, 2021</p>
<p>@author: yann</p>
<p>Utility module to verify if the network, if the various api services are available for our use, and that tries to load
either firefox's webdriver or chrome's</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Created on Apr 15, 2021

@author: yann

Utility module to verify if the network, if the various api services are available for our use, and that tries to load
either firefox&#39;s webdriver or chrome&#39;s
&#39;&#39;&#39;
from multiprocessing import Process, Value
import os
import requests
import time
import traceback
from urllib3.exceptions import NewConnectionError, MaxRetryError, TimeoutError, ConnectionError

from googletrans.client import Translator
from selenium import webdriver
from selenium.webdriver import chrome
from translator import is_lang_valid
import tweepy
from twitter_extraction import api
from webdriver_manager.chrome import ChromeDriverManager  # python3.7 -m pip install webdriver-manager
from webdriver_manager.firefox import GeckoDriverManager

TIMEOUT_DURATION = 5  #  for api requests


def is_connected_internet():
    &#39;&#39;&#39;Checks basic internet connection, returns a boolean
    &#39;&#39;&#39;
    url = &#34;http://www.google.com&#34;  #  the url doesn&#39;t matter as long as its a valid one

    try:
        requests.get(url, timeout=TIMEOUT_DURATION)
        # print(&#34;Connected to the Internet&#34;)
        return True

    except (requests.ConnectionError, requests.Timeout):
        print(&#34;No internet connection.&#34;)
        return False


def load_driver():  # le driver est créé
    &#39;&#39;&#39; Function that tries to load a webdriver in the RequestsHandler. If neither Chrome nor Firefox is installed on
    the machine, it won&#39;t work and will return an error.
    &#39;&#39;&#39;
    driver = None

    try:  #  first we try with Chrome
        options = chrome.options.Options()
        options.add_argument(&#34;--headless&#34;)
        print(&#34;Trying to load Chrome&#39;s webdriver...&#34;)
        driver = webdriver.Chrome(ChromeDriverManager().install(), options=options)
        print(&#34;Chrome&#39;s webdriver loaded with success!&#34;)

    except ValueError as e:  # when chrome is not found
        print(&#34;Chrome&#39;s webdriver couldn&#39;t be loaded.&#34;)
        print(e)

        try:  #  second with firefox
            options = webdriver.FirefoxOptions()
            options.headless = True
            print(&#34;Trying to load Firefox&#39;s webdriver...&#34;)
            driver = webdriver.Firefox(executable_path=GeckoDriverManager().install(),
                                       options=options,
                                       service_log_path=os.devnull)  # prevents the driver from generating logs
            print(&#34;Firefox&#39;s webdriver loaded with success!&#34;)

        except ValueError as e:  # when firefox is not found
            print(&#34;Firefox&#39;s webdriver couldn&#39;t be loaded.&#34;)
            print(e)

            raise ValueError(&#34;No webdriver could be loaded. Please install a recent version of Chrome or Firefox&#34; +
                             &#34; on your machine.&#34;)
            driver = None

        except Exception(e):  # any other exception is caught and printed, but no webdriver will be loaded

            driver = None

    finally:
        print(&#39;Finally reached in load_driver&#39;)
        return driver


def is_api_up(process, process_name: str, rh=None, iterations=1):
    &#39;&#39;&#39;Function that creates a process of the function passed as argument to test if the tested service is
    available or not.
    &#39;&#39;&#39;
    result = Value(&#39;i&#39;, True)  # we create a Value object to be able to retrieve the boolean value changed in the process
    if rh:  #  if the rh is needed
        args = [result, rh]
    else:
        args = [result]

    for i in range(iterations):  #  if we want to test it several times, we can by changing the iterations value

        p = Process(target=process, name=process_name, args=args)
        p.start()

        # Wait for sec_timeout seconds or until process finishes
        p.join(timeout=TIMEOUT_DURATION)

        if p.is_alive():
            p.kill()
            print(p.name + &#34; timed out and was killed.&#34;)
            p.join()
            result.value = False
            return

        elif iterations &gt; 1 and not result.value:  # in the case we want to test it again
            print(i, result.value)
            time.sleep(1)

        elif result.value:  # if true, then we exit the loop
            break

    return result.value


def is_detectlanguage_api_up(result: Value, txt=&#39;dummy request&#39;):
    &#39;&#39;&#39;Method to check if the detect-language API is available or not.
    Returns a boolean that answers the question
    &#39;&#39;&#39;
    try:  # if no error is raised, then the API is available
        is_lang_valid(txt, [&#39;fr&#39;])
        result.value = True
        return True
    except(AttributeError, MaxRetryError, NewConnectionError, TimeoutError, ConnectionError, requests.exceptions.ConnectionError):
        # the API raises an attribute error if too many requests were sent today or if the server is not available
        result.value = False
        return False


def is_imdb_api_up(rh):
    &#39;&#39;&#39;Checks if a value has been assigned to the RH&#39;s webdriver
    &#39;&#39;&#39;
    print(rh)
#     if rh.imdb_webdriver:
#         result.value = True
#     else:
#         result.value = False
#     return

    if rh.imdb_webdriver:  # if the webdriver is loaded then it will have a value other than None
        return True
    else:  # we might need to wait for a bit to load
        time.sleep(TIMEOUT_DURATION)
        if rh.imdb_webdriver:
            return True
        else:
            return False  # if at this point this is not loaded, there&#39;s no hope.


def is_tweepy_up(result: Value):
    &#39;&#39;&#39;Tests if the Twitter API is up by checking the output of Tweepy&#39;s requests
    &#39;&#39;&#39;
    try:
        result.value = True

        data = api.rate_limit_status()
        if (not data[&#39;resources&#39;][&#39;search&#39;][&#39;/search/tweets&#39;][&#39;remaining&#39;] or
                not data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/user_timeline&#39;][&#39;remaining&#39;]):
            result.value = False
        # data[&#39;resources&#39;][&#39;search&#39;][&#39;/search/tweets&#39;][&#39;remaining&#39;] # remaining requests for tweets
        # data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/user_timeline&#39;][&#39;remaining&#39;] # remaining requests for users
        # with the &#39;limit&#39; key, we get the original limit

#         print(data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/home_timeline&#39;])
#         print(&#34;/users/lookup &#34; + str(data[&#39;resources&#39;][&#39;users&#39;][&#39;/users/lookup&#39;][&#39;remaining&#39;]))
#         print(&#34;/search/tweets &#34; + str(data[&#39;resources&#39;][&#39;search&#39;][&#39;/search/tweets&#39;][&#39;remaining&#39;]))
#         print(&#34;/statuses/user_timeline &#34; + str(data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/user_timeline&#39;][&#39;remaining&#39;]))
#         print(&#34;/statuses/lookup &#34; + str(data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/lookup&#39;][&#39;remaining&#39;]))
#         print(&#34;/application/rate_limit_status &#34; + str(data[&#39;resources&#39;][&#39;application&#39;][&#39;/application/rate_limit_status&#39;][&#39;remaining&#39;]))

    except tweepy.error.RateLimitError:
        print(&#34;Rate limits for the Twitter API called too many times. Please wait your API credits to be reset.&#34;)
        result.value = False  # by default, but it needs to be updated to a warning
        return

    except tweepy.error.TweepError:
        print(&#34;Your Twitter API key is not valid.&#34;)
        result.value = False
        return

    except Exception:
        traceback.print_exc()
        result.value = False
        return


def is_tweepy_api_key_valid():
    try:
        api.rate_limit_status()
    except tweepy.error.TweepError as e:
        if e.api_code == 32:
            return False
        return True
    return True


def is_googletrans_api_up(result: Value, txt=&#39;dummy request&#39;):
    &#39;&#39;&#39;Method to check if the googletrans API is available or not.
    Returns a boolean that answers the question
    &#39;&#39;&#39;
    try:
        translator = Translator()
        output = translator.translate(txt, dest=&#39;fr&#39;)._response.status_code
        result.value = not (output == 429)  # if the output is equal to 429, it means we don&#39;t have anymore credits for today
    except Exception:  # if any exception is raised... Even though this scenario is not very probable
        result.value = False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.model.data_extraction.network_utils.is_api_up"><code class="name flex">
<span>def <span class="ident">is_api_up</span></span>(<span>process, process_name: str, rh=None, iterations=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that creates a process of the function passed as argument to test if the tested service is
available or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_api_up(process, process_name: str, rh=None, iterations=1):
    &#39;&#39;&#39;Function that creates a process of the function passed as argument to test if the tested service is
    available or not.
    &#39;&#39;&#39;
    result = Value(&#39;i&#39;, True)  # we create a Value object to be able to retrieve the boolean value changed in the process
    if rh:  #  if the rh is needed
        args = [result, rh]
    else:
        args = [result]

    for i in range(iterations):  #  if we want to test it several times, we can by changing the iterations value

        p = Process(target=process, name=process_name, args=args)
        p.start()

        # Wait for sec_timeout seconds or until process finishes
        p.join(timeout=TIMEOUT_DURATION)

        if p.is_alive():
            p.kill()
            print(p.name + &#34; timed out and was killed.&#34;)
            p.join()
            result.value = False
            return

        elif iterations &gt; 1 and not result.value:  # in the case we want to test it again
            print(i, result.value)
            time.sleep(1)

        elif result.value:  # if true, then we exit the loop
            break

    return result.value</code></pre>
</details>
</dd>
<dt id="src.model.data_extraction.network_utils.is_connected_internet"><code class="name flex">
<span>def <span class="ident">is_connected_internet</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks basic internet connection, returns a boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected_internet():
    &#39;&#39;&#39;Checks basic internet connection, returns a boolean
    &#39;&#39;&#39;
    url = &#34;http://www.google.com&#34;  #  the url doesn&#39;t matter as long as its a valid one

    try:
        requests.get(url, timeout=TIMEOUT_DURATION)
        # print(&#34;Connected to the Internet&#34;)
        return True

    except (requests.ConnectionError, requests.Timeout):
        print(&#34;No internet connection.&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="src.model.data_extraction.network_utils.is_detectlanguage_api_up"><code class="name flex">
<span>def <span class="ident">is_detectlanguage_api_up</span></span>(<span>result: <bound method BaseContext.Value of <multiprocessing.context.DefaultContext object at 0x7f9b1bd9e280>>, txt='dummy request')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to check if the detect-language API is available or not.
Returns a boolean that answers the question</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_detectlanguage_api_up(result: Value, txt=&#39;dummy request&#39;):
    &#39;&#39;&#39;Method to check if the detect-language API is available or not.
    Returns a boolean that answers the question
    &#39;&#39;&#39;
    try:  # if no error is raised, then the API is available
        is_lang_valid(txt, [&#39;fr&#39;])
        result.value = True
        return True
    except(AttributeError, MaxRetryError, NewConnectionError, TimeoutError, ConnectionError, requests.exceptions.ConnectionError):
        # the API raises an attribute error if too many requests were sent today or if the server is not available
        result.value = False
        return False</code></pre>
</details>
</dd>
<dt id="src.model.data_extraction.network_utils.is_googletrans_api_up"><code class="name flex">
<span>def <span class="ident">is_googletrans_api_up</span></span>(<span>result: <bound method BaseContext.Value of <multiprocessing.context.DefaultContext object at 0x7f9b1bd9e280>>, txt='dummy request')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to check if the googletrans API is available or not.
Returns a boolean that answers the question</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_googletrans_api_up(result: Value, txt=&#39;dummy request&#39;):
    &#39;&#39;&#39;Method to check if the googletrans API is available or not.
    Returns a boolean that answers the question
    &#39;&#39;&#39;
    try:
        translator = Translator()
        output = translator.translate(txt, dest=&#39;fr&#39;)._response.status_code
        result.value = not (output == 429)  # if the output is equal to 429, it means we don&#39;t have anymore credits for today
    except Exception:  # if any exception is raised... Even though this scenario is not very probable
        result.value = False</code></pre>
</details>
</dd>
<dt id="src.model.data_extraction.network_utils.is_imdb_api_up"><code class="name flex">
<span>def <span class="ident">is_imdb_api_up</span></span>(<span>rh)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a value has been assigned to the RH's webdriver</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_imdb_api_up(rh):
    &#39;&#39;&#39;Checks if a value has been assigned to the RH&#39;s webdriver
    &#39;&#39;&#39;
    print(rh)
#     if rh.imdb_webdriver:
#         result.value = True
#     else:
#         result.value = False
#     return

    if rh.imdb_webdriver:  # if the webdriver is loaded then it will have a value other than None
        return True
    else:  # we might need to wait for a bit to load
        time.sleep(TIMEOUT_DURATION)
        if rh.imdb_webdriver:
            return True
        else:
            return False  # if at this point this is not loaded, there&#39;s no hope.</code></pre>
</details>
</dd>
<dt id="src.model.data_extraction.network_utils.is_tweepy_api_key_valid"><code class="name flex">
<span>def <span class="ident">is_tweepy_api_key_valid</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_tweepy_api_key_valid():
    try:
        api.rate_limit_status()
    except tweepy.error.TweepError as e:
        if e.api_code == 32:
            return False
        return True
    return True</code></pre>
</details>
</dd>
<dt id="src.model.data_extraction.network_utils.is_tweepy_up"><code class="name flex">
<span>def <span class="ident">is_tweepy_up</span></span>(<span>result: <bound method BaseContext.Value of <multiprocessing.context.DefaultContext object at 0x7f9b1bd9e280>>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the Twitter API is up by checking the output of Tweepy's requests</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_tweepy_up(result: Value):
    &#39;&#39;&#39;Tests if the Twitter API is up by checking the output of Tweepy&#39;s requests
    &#39;&#39;&#39;
    try:
        result.value = True

        data = api.rate_limit_status()
        if (not data[&#39;resources&#39;][&#39;search&#39;][&#39;/search/tweets&#39;][&#39;remaining&#39;] or
                not data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/user_timeline&#39;][&#39;remaining&#39;]):
            result.value = False
        # data[&#39;resources&#39;][&#39;search&#39;][&#39;/search/tweets&#39;][&#39;remaining&#39;] # remaining requests for tweets
        # data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/user_timeline&#39;][&#39;remaining&#39;] # remaining requests for users
        # with the &#39;limit&#39; key, we get the original limit

#         print(data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/home_timeline&#39;])
#         print(&#34;/users/lookup &#34; + str(data[&#39;resources&#39;][&#39;users&#39;][&#39;/users/lookup&#39;][&#39;remaining&#39;]))
#         print(&#34;/search/tweets &#34; + str(data[&#39;resources&#39;][&#39;search&#39;][&#39;/search/tweets&#39;][&#39;remaining&#39;]))
#         print(&#34;/statuses/user_timeline &#34; + str(data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/user_timeline&#39;][&#39;remaining&#39;]))
#         print(&#34;/statuses/lookup &#34; + str(data[&#39;resources&#39;][&#39;statuses&#39;][&#39;/statuses/lookup&#39;][&#39;remaining&#39;]))
#         print(&#34;/application/rate_limit_status &#34; + str(data[&#39;resources&#39;][&#39;application&#39;][&#39;/application/rate_limit_status&#39;][&#39;remaining&#39;]))

    except tweepy.error.RateLimitError:
        print(&#34;Rate limits for the Twitter API called too many times. Please wait your API credits to be reset.&#34;)
        result.value = False  # by default, but it needs to be updated to a warning
        return

    except tweepy.error.TweepError:
        print(&#34;Your Twitter API key is not valid.&#34;)
        result.value = False
        return

    except Exception:
        traceback.print_exc()
        result.value = False
        return</code></pre>
</details>
</dd>
<dt id="src.model.data_extraction.network_utils.load_driver"><code class="name flex">
<span>def <span class="ident">load_driver</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that tries to load a webdriver in the RequestsHandler. If neither Chrome nor Firefox is installed on
the machine, it won't work and will return an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_driver():  # le driver est créé
    &#39;&#39;&#39; Function that tries to load a webdriver in the RequestsHandler. If neither Chrome nor Firefox is installed on
    the machine, it won&#39;t work and will return an error.
    &#39;&#39;&#39;
    driver = None

    try:  #  first we try with Chrome
        options = chrome.options.Options()
        options.add_argument(&#34;--headless&#34;)
        print(&#34;Trying to load Chrome&#39;s webdriver...&#34;)
        driver = webdriver.Chrome(ChromeDriverManager().install(), options=options)
        print(&#34;Chrome&#39;s webdriver loaded with success!&#34;)

    except ValueError as e:  # when chrome is not found
        print(&#34;Chrome&#39;s webdriver couldn&#39;t be loaded.&#34;)
        print(e)

        try:  #  second with firefox
            options = webdriver.FirefoxOptions()
            options.headless = True
            print(&#34;Trying to load Firefox&#39;s webdriver...&#34;)
            driver = webdriver.Firefox(executable_path=GeckoDriverManager().install(),
                                       options=options,
                                       service_log_path=os.devnull)  # prevents the driver from generating logs
            print(&#34;Firefox&#39;s webdriver loaded with success!&#34;)

        except ValueError as e:  # when firefox is not found
            print(&#34;Firefox&#39;s webdriver couldn&#39;t be loaded.&#34;)
            print(e)

            raise ValueError(&#34;No webdriver could be loaded. Please install a recent version of Chrome or Firefox&#34; +
                             &#34; on your machine.&#34;)
            driver = None

        except Exception(e):  # any other exception is caught and printed, but no webdriver will be loaded

            driver = None

    finally:
        print(&#39;Finally reached in load_driver&#39;)
        return driver</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.model.data_extraction" href="index.html">src.model.data_extraction</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.model.data_extraction.network_utils.is_api_up" href="#src.model.data_extraction.network_utils.is_api_up">is_api_up</a></code></li>
<li><code><a title="src.model.data_extraction.network_utils.is_connected_internet" href="#src.model.data_extraction.network_utils.is_connected_internet">is_connected_internet</a></code></li>
<li><code><a title="src.model.data_extraction.network_utils.is_detectlanguage_api_up" href="#src.model.data_extraction.network_utils.is_detectlanguage_api_up">is_detectlanguage_api_up</a></code></li>
<li><code><a title="src.model.data_extraction.network_utils.is_googletrans_api_up" href="#src.model.data_extraction.network_utils.is_googletrans_api_up">is_googletrans_api_up</a></code></li>
<li><code><a title="src.model.data_extraction.network_utils.is_imdb_api_up" href="#src.model.data_extraction.network_utils.is_imdb_api_up">is_imdb_api_up</a></code></li>
<li><code><a title="src.model.data_extraction.network_utils.is_tweepy_api_key_valid" href="#src.model.data_extraction.network_utils.is_tweepy_api_key_valid">is_tweepy_api_key_valid</a></code></li>
<li><code><a title="src.model.data_extraction.network_utils.is_tweepy_up" href="#src.model.data_extraction.network_utils.is_tweepy_up">is_tweepy_up</a></code></li>
<li><code><a title="src.model.data_extraction.network_utils.load_driver" href="#src.model.data_extraction.network_utils.load_driver">load_driver</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>